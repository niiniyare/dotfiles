"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prompt_project_types = exports.get_project_types = exports.is_multi_type = exports.get_source = void 0;

var _ora = _interopRequireDefault(require("ora"));

var _chalk = _interopRequireDefault(require("chalk"));

var _enquirer = require("enquirer");

var _ = require("./..");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * get_source will return path for plugins
 * source can be url - relative local path or "superplate"
 *
 */
const get_source = async (source, branch, downloadType) => {
  /**
   * Replace path if default
   */
  const sourceSpinner = (0, _ora.default)(`Checking provided source ${_chalk.default.bold`"${source}${branch ? ` - ${branch}` : ""}"`}`);
  sourceSpinner.start();
  const sourcePath = source !== null && source !== void 0 ? source : "https://github.com/pankod/superplate-core-plugins.git";
  const isPathExists = await _.FSHelper.IsPathExists(sourcePath);

  if (isPathExists) {
    /**
     * check local path
     */
    sourceSpinner.succeed("Found local source.");
    return {
      path: sourcePath
    };
  } else if (downloadType === "zip") {
    sourceSpinner.text = "Checking remote source...";
    sourceSpinner.text = "Remote source found. Downloading...";

    try {
      const cloneResponse = await _.DownloadHelper.DownloadAndGetPath(sourcePath);

      if (cloneResponse) {
        sourceSpinner.succeed("Downloaded remote source successfully.");
        return {
          path: cloneResponse
        };
      }

      sourceSpinner.fail("Could not retrieve source repository.");
      return {
        error: "Could not retrieve source repository."
      };
    } catch (e) {
      sourceSpinner.fail("Could not retrieve source repository.");
      sourceSpinner.text = "Try to use git instead of zip...";
      return {
        error: "Could not retrieve source repository."
      };
    }
  } else {
    /**
     * Check repo exists
     * clone and return path if exists
     */
    sourceSpinner.text = "Checking remote source...";
    const repoStatus = await _.GitHelper.IsRepoExist(sourcePath);

    if (repoStatus.exists === true) {
      sourceSpinner.text = "Remote source found. Cloning...";

      try {
        const cloneResponse = await _.GitHelper.CloneAndGetPath(sourcePath, branch);

        if (cloneResponse) {
          sourceSpinner.succeed("Cloned remote source successfully.");
          return {
            path: cloneResponse
          };
        }

        sourceSpinner.fail("Could not retrieve source repository.");
        return {
          error: "Could not retrieve source repository."
        };
      } catch (e) {
        `${e}`;
        sourceSpinner.fail("Could not retrieve source repository.");
        return {
          error: "Could not retrieve source repository."
        };
      }
    } else {
      sourceSpinner.fail("Could not found source repository.");
      return {
        error: repoStatus.error
      };
    }
  }
};

exports.get_source = get_source;

const is_multi_type = async (source) => {
  if (source) {
    const checkRootPrompt = await _.FSHelper.IsPathExists(`${source}/prompt.js`);
    return !checkRootPrompt;
  }

  return false;
};

exports.is_multi_type = is_multi_type;

const get_project_types = async source => {
  const projectTypes = []; // get project types => react,nextjs,refine ...etc

  const files = await _.FSHelper.ReadDir(source);

  for (const file of files) {
    const existPromptFile = await _.FSHelper.IsPathExists(`${source}/${file}/prompt.js`);

    if (existPromptFile) {
      projectTypes.push({
        title: file,
        value: file
      });
    }
  }

  return projectTypes;
};

exports.get_project_types = get_project_types;

const prompt_project_types = async (source, types, typeFromArgs) => {
  let projectType = "";

  if (types.find(p => p.title === typeFromArgs) && typeof typeFromArgs === "string") {
    projectType = typeFromArgs;
  } else {
    const filteredWithContains = types.filter(p => p.title.includes(typeFromArgs !== null && typeFromArgs !== void 0 ? typeFromArgs : ""));
    const response = await (0, _enquirer.prompt)({
      type: "select",
      name: "projectType",
      message: "Choose a project template",
      choices: (filteredWithContains.length > 0 ? filteredWithContains : types).map(p => _.HumanizeChoices.get(p.title)).map(p => ({
        type: "select",
        name: p.value,
        message: p.title,
        hint: p.description
      }))
    });
    projectType = response.projectType;
  }

  return [`${source}/${projectType}`, projectType];
};

exports.prompt_project_types = prompt_project_types;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9IZWxwZXIvc291cmNlL2luZGV4LnRzIl0sIm5hbWVzIjpbImdldF9zb3VyY2UiLCJzb3VyY2UiLCJicmFuY2giLCJkb3dubG9hZFR5cGUiLCJzb3VyY2VTcGlubmVyIiwiY2hhbGsiLCJib2xkIiwic3RhcnQiLCJzb3VyY2VQYXRoIiwiaXNQYXRoRXhpc3RzIiwiRlNIZWxwZXIiLCJJc1BhdGhFeGlzdHMiLCJzdWNjZWVkIiwicGF0aCIsInRleHQiLCJjbG9uZVJlc3BvbnNlIiwiRG93bmxvYWRIZWxwZXIiLCJEb3dubG9hZEFuZEdldFBhdGgiLCJmYWlsIiwiZXJyb3IiLCJlIiwicmVwb1N0YXR1cyIsIkdpdEhlbHBlciIsIklzUmVwb0V4aXN0IiwiZXhpc3RzIiwiQ2xvbmVBbmRHZXRQYXRoIiwiaXNfbXVsdGlfdHlwZSIsImNoZWNrUm9vdFByb21wdCIsImdldF9wcm9qZWN0X3R5cGVzIiwicHJvamVjdFR5cGVzIiwiZmlsZXMiLCJSZWFkRGlyIiwiZmlsZSIsImV4aXN0UHJvbXB0RmlsZSIsInB1c2giLCJ0aXRsZSIsInZhbHVlIiwicHJvbXB0X3Byb2plY3RfdHlwZXMiLCJ0eXBlcyIsInR5cGVGcm9tQXJncyIsInByb2plY3RUeXBlIiwiZmluZCIsInAiLCJmaWx0ZXJlZFdpdGhDb250YWlucyIsImZpbHRlciIsImluY2x1ZGVzIiwicmVzcG9uc2UiLCJ0eXBlIiwibmFtZSIsIm1lc3NhZ2UiLCJjaG9pY2VzIiwibGVuZ3RoIiwibWFwIiwiSHVtYW5pemVDaG9pY2VzIiwiZ2V0IiwiaGludCIsImRlc2NyaXB0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjTyxNQUFNQSxVQUF1QixHQUFHLE9BQU9DLE1BQVAsRUFBZUMsTUFBZixFQUF1QkMsWUFBdkIsS0FBd0M7QUFDM0U7QUFDSjtBQUNBO0FBQ0ksUUFBTUMsYUFBYSxH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akMsQ0FEeUIsQ0FBN0I7QUFHQSxVQUFNTyxRQUFRLEdBQUcsTUFBTSxzQkFBTztBQUMxQkMsTUFBQUEsSUFBSSxFQUFFLFFBRG9CO0FBRTFCQyxNQUFBQSxJQUFJLEVBQUUsYUFGb0I7QUFHMUJDLE1BQUFBLE9BQU8sRUFBRSwyQkFIaUI7QUFJMUJDLE1BQUFBLE9BQU8sRUFBRSxDQUFDUCxvQkFBb0IsQ0FBQ1EsTUFBckIsR0FBOEIsQ0FBOUIsR0FDSlIsb0JBREksR0FFSkwsS0FGRyxFQUlKYyxHQUpJLENBSUNWLENBQUQsSUFBT1csa0JBQWdCQyxHQUFoQixDQUFvQlosQ0FBQyxDQUFDUCxLQUF0QixDQUpQLEVBS0ppQixHQUxJLENBS0NWLENBQUQsS0FBUTtBQUNUSyxRQUFBQSxJQUFJLEVBQUUsUUFERztBQUVUQyxRQUFBQSxJQUFJLEVBQUVOLENBQUMsQ0FBQ04sS0FGQztBQUdUYSxRQUFBQSxPQUFPLEVBQUVQLENBQUMsQ0FBQ1AsS0FIRjtBQUlUb0IsUUFBQUEsSUFBSSxFQUFFYixDQUFDLENBQUNjO0FBSkMsT0FBUixDQUxBO0FBSmlCLEtBQVAsQ0FBdkI7QUFpQkFoQixJQUFBQSxXQUFXLEdBQUlNLFFBQUQsQ0FBc0NOLFdBQXBEO0FBQ0g7O0FBRUQsU0FBTyxDQUFFLEdBQUV2QyxNQUFPLElBQUd1QyxXQUFZLEVBQTFCLEVBQTZCQSxXQUE3QixDQUFQO0FBQ0gsQ0FyQ00iLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBnZXRfc291cmNlIHdpbGwgcmV0dXJuIHBhdGggZm9yIHBsdWdpbnNcbiAqIHNvdXJjZSBjYW4gYmUgdXJsIC0gcmVsYXRpdmUgbG9jYWwgcGF0aCBvciBcInN1cGVycGxhdGVcIlxuICpcbiAqL1xuaW1wb3J0IG9yYSBmcm9tIFwib3JhXCI7XG5pbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgeyBwcm9tcHQgfSBmcm9tIFwiZW5xdWlyZXJcIjtcblxuaW1wb3J0IHsgR2l0SGVscGVyLCBGU0hlbHBlciwgSHVtYW5pemVDaG9pY2VzLCBEb3dubG9hZEhlbHBlciB9IGZyb20gXCJASGVscGVyXCI7XG5cbnR5cGUgU291cmNlUmVzcG9uc2UgPSB7IHBhdGg/OiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH07XG50eXBlIEdldFNvdXJjZUZuID0gKFxuICAgIHNvdXJjZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGJyYW5jaD86IHN0cmluZyxcbiAgICBkb3dubG9hZFR5cGU/OiBcInppcFwiIHwgXCJnaXRcIixcbikgPT4gUHJvbWlzZTxTb3VyY2VSZXNwb25zZT47XG5cbmV4cG9ydCBjb25zdCBnZXRfc291cmNlOiBHZXRTb3VyY2VGbiA9IGFzeW5jIChzb3VyY2UsIGJyYW5jaCwgZG93bmxvYWRUeXBlKSA9PiB7XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBwYXRoIGlmIGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb25zdCBzb3VyY2VTcGlubmVyID0gb3JhKFxuICAgICAgICBgQ2hlY2tpbmcgcHJvdmlkZWQgc291cmNlICR7Y2hhbGsuYm9sZGBcIiR7c291cmNlfSR7XG4gICAgICAgICAgICBicmFuY2ggPyBgIC0gJHticmFuY2h9YCA6IFwiXCJcbiAgICAgICAgfVwiYH1gLFxuICAgICk7XG4gICAgc291cmNlU3Bpbm5lci5zdGFydCgpO1xuXG4gICAgY29uc3Qgc291cmNlUGF0aCA9XG4gICAgICAgIHNvdXJjZSA/PyBcImh0dHBzOi8vZ2l0aHViLmNvbS9wYW5rb2Qvc3VwZXJwbGF0ZS1jb3JlLXBsdWdpbnMuZ2l0XCI7XG5cbiAgICBjb25zdCBpc1BhdGhFeGlzdHMgPSBhd2FpdCBGU0hlbHBlci5Jc1BhdGhFeGlzdHMoc291cmNlUGF0aCk7XG4gICAgaWYgKGlzUGF0aEV4aXN0cykge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2sgbG9jYWwgcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgc291cmNlU3Bpbm5lci5zdWNjZWVkKFwiRm91bmQgbG9jYWwgc291cmNlLlwiKTtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogc291cmNlUGF0aCB9O1xuICAgIH0gZWxzZSBpZiAoZG93bmxvYWRUeXBlID09PSBcInppcFwiKSB7XG4gICAgICAgIHNvdXJjZVNwaW5uZXIudGV4dCA9IFwiQ2hlY2tpbmcgcmVtb3RlIHNvdXJjZS4uLlwiO1xuICAgICAgICBzb3VyY2VTcGlubmVyLnRleHQgPSBcIlJlbW90ZSBzb3VyY2UgZm91bmQuIERvd25sb2FkaW5nLi4uXCI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lUmVzcG9uc2UgPSBhd2FpdCBEb3dubG9hZEhlbHBlci5Eb3dubG9hZEFuZEdldFBhdGgoXG4gICAgICAgICAgICAgICAgc291cmNlUGF0aCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoY2xvbmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwaW5uZXIuc3VjY2VlZChcIkRvd25sb2FkZWQgcmVtb3RlIHNvdXJjZSBzdWNjZXNzZnVsbHkuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGNsb25lUmVzcG9uc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZVNwaW5uZXIuZmFpbChcIkNvdWxkIG5vdCByZXRyaWV2ZSBzb3VyY2UgcmVwb3NpdG9yeS5cIik7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIkNvdWxkIG5vdCByZXRyaWV2ZSBzb3VyY2UgcmVwb3NpdG9yeS5cIiB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzb3VyY2VTcGlubmVyLmZhaWwoXCJDb3VsZCBub3QgcmV0cmlldmUgc291cmNlIHJlcG9zaXRvcnkuXCIpO1xuXG4gICAgICAgICAgICBzb3VyY2VTcGlubmVyLnRleHQgPSBcIlRyeSB0byB1c2UgZ2l0IGluc3RlYWQgb2YgemlwLi4uXCI7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJDb3VsZCBub3QgcmV0cmlldmUgc291cmNlIHJlcG9zaXRvcnkuXCIgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayByZXBvIGV4aXN0c1xuICAgICAgICAgKiBjbG9uZSBhbmQgcmV0dXJuIHBhdGggaWYgZXhpc3RzXG4gICAgICAgICAqL1xuICAgICAgICBzb3VyY2VTcGlubmVyLnRleHQgPSBcIkNoZWNraW5nIHJlbW90ZSBzb3VyY2UuLi5cIjtcbiAgICAgICAgY29uc3QgcmVwb1N0YXR1cyA9IGF3YWl0IEdpdEhlbHBlci5Jc1JlcG9FeGlzdChzb3VyY2VQYXRoKTtcbiAgICAgICAgaWYgKHJlcG9TdGF0dXMuZXhpc3RzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzb3VyY2VTcGlubmVyLnRleHQgPSBcIlJlbW90ZSBzb3VyY2UgZm91bmQuIENsb25pbmcuLi5cIjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVSZXNwb25zZSA9IGF3YWl0IEdpdEhlbHBlci5DbG9uZUFuZEdldFBhdGgoXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChjbG9uZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwaW5uZXIuc3VjY2VlZChcIkNsb25lZCByZW1vdGUgc291cmNlIHN1Y2Nlc3NmdWxseS5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGNsb25lUmVzcG9uc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc291cmNlU3Bpbm5lci5mYWlsKFwiQ291bGQgbm90IHJldHJpZXZlIHNvdXJjZSByZXBvc2l0b3J5LlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJDb3VsZCBub3QgcmV0cmlldmUgc291cmNlIHJlcG9zaXRvcnkuXCIgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBgJHtlfWA7XG4gICAgICAgICAgICAgICAgc291cmNlU3Bpbm5lci5mYWlsKFwiQ291bGQgbm90IHJldHJpZXZlIHNvdXJjZSByZXBvc2l0b3J5LlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJDb3VsZCBub3QgcmV0cmlldmUgc291cmNlIHJlcG9zaXRvcnkuXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVNwaW5uZXIuZmFpbChcIkNvdWxkIG5vdCBmb3VuZCBzb3VyY2UgcmVwb3NpdG9yeS5cIik7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogcmVwb1N0YXR1cy5lcnJvciB9O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzX211bHRpX3R5cGUgPSBhc3luYyAoXG4gICAgc291cmNlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrUm9vdFByb21wdCA9IGF3YWl0IEZTSGVscGVyLklzUGF0aEV4aXN0cyhcbiAgICAgICAgICAgIGAke3NvdXJjZX0vcHJvbXB0LmpzYCxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gIWNoZWNrUm9vdFByb21wdDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldF9wcm9qZWN0X3R5cGVzID0gYXN5bmMgKHNvdXJjZTogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4gPT4ge1xuICAgIGNvbnN0IHByb2plY3RUeXBlczogYW55W10gPSBbXTtcblxuICAgIC8vIGdldCBwcm9qZWN0IHR5cGVzID0+IHJlYWN0LG5leHRqcyxyZWZpbmUgLi4uZXRjXG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBGU0hlbHBlci5SZWFkRGlyKHNvdXJjZSk7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RQcm9tcHRGaWxlID0gYXdhaXQgRlNIZWxwZXIuSXNQYXRoRXhpc3RzKFxuICAgICAgICAgICAgYCR7c291cmNlfS8ke2ZpbGV9L3Byb21wdC5qc2AsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGV4aXN0UHJvbXB0RmlsZSkge1xuICAgICAgICAgICAgcHJvamVjdFR5cGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBmaWxlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmaWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvamVjdFR5cGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHByb21wdF9wcm9qZWN0X3R5cGVzID0gYXN5bmMgKFxuICAgIHNvdXJjZTogc3RyaW5nLFxuICAgIHR5cGVzOiBhbnlbXSxcbiAgICB0eXBlRnJvbUFyZ3M/OiBzdHJpbmcsXG4pOiBQcm9taXNlPFtwcm9qZWN0VHlwZVBhdGg6IHN0cmluZywgcHJvamVjdFR5cGU6IHN0cmluZ10+ID0+IHtcbiAgICBsZXQgcHJvamVjdFR5cGUgPSBcIlwiO1xuXG4gICAgaWYgKFxuICAgICAgICB0eXBlcy5maW5kKChwKSA9PiBwLnRpdGxlID09PSB0eXBlRnJvbUFyZ3MpICYmXG4gICAgICAgIHR5cGVvZiB0eXBlRnJvbUFyZ3MgPT09IFwic3RyaW5nXCJcbiAgICApIHtcbiAgICAgICAgcHJvamVjdFR5cGUgPSB0eXBlRnJvbUFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRXaXRoQ29udGFpbnMgPSB0eXBlcy5maWx0ZXIoKHApID0+XG4gICAgICAgICAgICBwLnRpdGxlLmluY2x1ZGVzKHR5cGVGcm9tQXJncyA/PyBcIlwiKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm9tcHQoe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgIG5hbWU6IFwicHJvamVjdFR5cGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2hvb3NlIGEgcHJvamVjdCB0ZW1wbGF0ZVwiLFxuICAgICAgICAgICAgY2hvaWNlczogKGZpbHRlcmVkV2l0aENvbnRhaW5zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IGZpbHRlcmVkV2l0aENvbnRhaW5zXG4gICAgICAgICAgICAgICAgOiB0eXBlc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IEh1bWFuaXplQ2hvaWNlcy5nZXQocC50aXRsZSkpXG4gICAgICAgICAgICAgICAgLm1hcCgocCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcC50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgaGludDogcC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2plY3RUeXBlID0gKHJlc3BvbnNlIGFzIHsgcHJvamVjdFR5cGU6IHN0cmluZyB9KS5wcm9qZWN0VHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2Ake3NvdXJjZX0vJHtwcm9qZWN0VHlwZX1gLCBwcm9qZWN0VHlwZV07XG59O1xuIl19